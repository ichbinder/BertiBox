<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BertiBox - Playlist Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .playlist-item {
            cursor: move;
        }
        .current-tag {
            background-color: #e9ecef;
        }
        .title-truncate {
            max-width: 300px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light mb-4">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">BertiBox</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="/">Verwaltung</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/explorer">Explorer</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/player">Player</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <h1>BertiBox - Playlist Manager</h1>
        
        <!-- Aktueller Tag -->
        <div class="card mb-4">
            <div class="card-header">
                Aktueller Tag
            </div>
            <div class="card-body">
                <p id="current-tag" class="mb-0">Kein Tag erkannt</p>
            </div>
        </div>
        
        <!-- Tags und Playlists -->
        <div class="row">
            <div class="col-md-6 mb-4 mb-md-0">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span>Tags</span>
                        <button class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#addTagModal">
                            <i class="bi bi-plus"></i> Neuer Tag
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="list-group" id="tag-list">
                            <!-- Tags werden hier dynamisch eingefügt -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        Playlist
                    </div>
                    <div class="card-body">
                        <div id="playlist-items" class="list-group">
                            <!-- Playlist-Items werden hier dynamisch eingefügt -->
                        </div>
                        <div class="mt-3">
                            <button class="btn btn-primary btn-sm" id="add-to-playlist" disabled>
                                <i class="bi bi-plus"></i> MP3 zur Playlist hinzufügen
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MP3 Upload Section -->
    <div class="container mt-4">
        <div class="card">
            <div class="card-header">
                MP3 Dateien hochladen
            </div>
            <div class="card-body">
                <div id="drop-zone" class="border rounded p-5 text-center mb-3" style="border-style: dashed !important;">
                    <p>MP3, WAV oder OGG Dateien hierher ziehen oder</p>
                    <input type="file" id="file-input" accept="audio/mpeg,audio/wav,audio/ogg" multiple style="display: none;">
                    <button type="button" class="btn btn-secondary" onclick="document.getElementById('file-input').click();">
                        <i class="bi bi-folder2-open"></i> Dateien auswählen
                    </button>
                    <p class="form-text mt-2">Nur MP3, WAV oder OGG Dateien erlaubt.</p>
                </div>
                <div id="upload-progress" class="mt-3" style="display: none;">
                    <h5>Upload Fortschritt:</h5>
                    <ul id="upload-list" class="list-group"></ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal für neuen Tag -->
    <div class="modal fade" id="addTagModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Neuen Tag hinzufügen</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="addTagForm">
                        <div class="mb-3">
                            <label for="tagId" class="form-label">Tag ID</label>
                            <input type="text" class="form-control" id="tagId" required>
                        </div>
                        <div class="mb-3">
                            <label for="tagName" class="form-label">Name (optional)</label>
                            <input type="text" class="form-control" id="tagName">
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                    <button type="button" class="btn btn-primary" id="saveTag">Speichern</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal für MP3 zur Playlist hinzufügen -->
    <div class="modal fade" id="addToPlaylistModal" tabindex="-1" aria-labelledby="addToPlaylistModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addToPlaylistModalLabel">Dateien zur Playlist hinzufügen</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <nav aria-label="breadcrumb" id="modal-breadcrumb" class="mb-2">
                        <ol class="breadcrumb mb-1">
                            <!-- Breadcrumb items will be added dynamically -->
                        </ol>
                    </nav>

                    <div id="modal-loading-indicator" class="text-center my-3" style="display: none;">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Laden...</span>
                        </div>
                    </div>

                    <ul class="list-group" id="modal-file-list">
                        <!-- Items will be loaded here -->
                    </ul>
                    
                    <div id="modal-selection-info" class="mt-2 text-muted" style="font-size: 0.9em;">
                         0 Datei(en) ausgewählt.
                     </div>
                    
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                    <button type="button" class="btn btn-primary" id="saveToPlaylist" disabled>
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display: none;"></span>
                         Auswahl hinzufügen
                     </button> 
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
    <script>
        const socket = io();
        let currentTagId = null;
        let currentPlaylistId = null;
        let sortablePlaylist = null;
        let addTagModal = null;
        let addToPlaylistModal = null;
        
        // --- Upload Elements ---
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const uploadProgressDiv = document.getElementById('upload-progress');
        const uploadList = document.getElementById('upload-list');
        
        // --- Modal 'Add to Playlist' specific variables ---
        let currentModalPath = '/'; // Path within the modal browser
        let selectedModalItems = new Set(); // Set to store selected file paths
        const modalLoadingIndicator = document.getElementById('modal-loading-indicator');
        const modalFileList = document.getElementById('modal-file-list');
        const modalBreadcrumb = document.getElementById('modal-breadcrumb').querySelector('.breadcrumb');
        const modalSelectionInfo = document.getElementById('modal-selection-info');
        const modalSaveButton = document.getElementById('saveToPlaylist');
        
        // Modal-Instanzen initialisieren
        document.addEventListener('DOMContentLoaded', function() {
            addTagModal = new bootstrap.Modal(document.getElementById('addTagModal'));
            // Listener for when the modal is shown
            const addToPlaylistModalElement = document.getElementById('addToPlaylistModal');
            addToPlaylistModal = new bootstrap.Modal(addToPlaylistModalElement);
            addToPlaylistModalElement.addEventListener('show.bs.modal', function (event) {
                console.log("Add to Playlist Modal opened");
                currentModalPath = '/'; // Reset path
                selectedModalItems.clear(); // Clear previous selection
                updateModalSelectionUI(); // Update button state and count
                loadModalDirectoryContent(currentModalPath); // Load root content
            });

            loadTags();

             // Add listener for the modal save button
             modalSaveButton.addEventListener('click', saveModalSelectionToPlaylist);
        });
        
        // Socket.IO Events
        socket.on('connect', () => {
            console.log('Connected to management socket');
        });
        
        socket.on('tag_detected', function(data) {
            const detectedTagId = data.tag_id;
            console.log('tag_detected event received:', detectedTagId);
            currentTagId = detectedTagId;
            document.getElementById('current-tag').textContent = detectedTagId ? `Tag ID: ${detectedTagId}` : 'Kein Tag erkannt';
            
            loadTags();
            
            if (detectedTagId) {
                loadPlaylistForTag(detectedTagId);
            } else {
                currentPlaylistId = null;
                document.getElementById('add-to-playlist').disabled = true;
                displayPlaylistItems([]);
            }
        });
        
        // Tags laden
        function loadTags() {
            console.log("Loading tags...");
            fetch('/api/tags')
                .then(response => response.json())
                .then(data => {
                    console.log("Tags received:", data);
                    const tags = data.tags || data; // Handle both formats
                    const tagList = document.getElementById('tag-list');
                    tagList.innerHTML = '';
                    
                    tags.forEach(tag => {
                        const tagElement = document.createElement('div');
                        tagElement.className = `list-group-item list-group-item-action ${tag.tag_id === currentTagId ? 'current-tag' : ''}`;
                        tagElement.innerHTML = `
                            <div class="d-flex justify-content-between align-items-center">
                                <div onclick="selectTag('${tag.tag_id}')" style="cursor: pointer; flex-grow: 1;" title="Tag ID: ${tag.tag_id}\nPlaylist ID: ${tag.playlist_id || 'N/A'}">
                                    <strong>${tag.name || tag.tag_id}</strong>
                                    ${tag.playlist_name ? `<br><small>${tag.playlist_name}</small>` : ''}
                                </div>
                                <div>
                                    <button class="btn btn-sm btn-outline-primary me-2" onclick="editTag('${tag.tag_id}', '${tag.name || ''}')" title="Tag bearbeiten">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger" onclick="deleteTag('${tag.tag_id}')" title="Tag löschen">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            </div>
                        `;
                        tagList.appendChild(tagElement);
                    });
                })
                .catch(error => console.error("Error loading tags:", error));
        }
        
        // Funktion zum Laden der Playlist für einen gegebenen Tag
        function loadPlaylistForTag(tagId) {
            console.log(`Loading playlist for tag: ${tagId}`);
            fetch(`/api/tags/${tagId}/playlist`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                 })
                .then(data => {
                    console.log(`Playlist data received for tag ${tagId}:`, data);
                    if (data && data.id !== null && data.id !== undefined) {
                        currentPlaylistId = data.id;
                        document.getElementById('add-to-playlist').disabled = false;
                        displayPlaylistItems(data.items || []);
                    } else {
                        console.warn(`No valid playlist found for tag ${tagId}. Displaying empty.`);
                        currentPlaylistId = null;
                        document.getElementById('add-to-playlist').disabled = true;
                        displayPlaylistItems([]);
                    }
                })
                .catch(error => {
                     console.error(`Error loading playlist for tag ${tagId}:`, error);
                     const playlistContainer = document.getElementById('playlist-items');
                     playlistContainer.innerHTML = '<div class="list-group-item text-danger">Fehler beim Laden der Playlist.</div>';
                     document.getElementById('add-to-playlist').disabled = true;
                     currentPlaylistId = null;
                });
        }
        
        // Tag auswählen
        function selectTag(tagId) {
            console.log(`Tag selected via click: ${tagId}`);
            currentTagId = tagId;
            document.getElementById('current-tag').textContent = `Tag ID: ${currentTagId}`;
            
            loadPlaylistForTag(tagId);
            
            loadTags();
        }
        
        // Playlist-Items anzeigen und SortableJS initialisieren
        function displayPlaylistItems(items) {
            console.log("Displaying playlist items:", items);
            const playlistContainer = document.getElementById('playlist-items');

            // 1. Destroy existing Sortable instance *before* clearing the container
            if (sortablePlaylist) {
                try {
                    console.log("Destroying previous Sortable instance.");
                    sortablePlaylist.destroy();
                    sortablePlaylist = null; // Ensure it's reset
                } catch (e) {
                    console.error("Error destroying Sortable instance:", e);
                    // Continue execution even if destroy fails?
                }
            }

            // 2. Clear current items from the container
            playlistContainer.innerHTML = ''; 

            // 3. Populate the container with new items
            if (!items || items.length === 0) {
                 playlistContainer.innerHTML = '<div class="list-group-item">Playlist ist leer.</div>';
            } else {
                items.forEach(item => {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'list-group-item playlist-item d-flex justify-content-between align-items-center';
                    itemElement.setAttribute('data-id', item.id);
                    itemElement.innerHTML = `
                        <span class="title-truncate" title="${item.mp3_file} (ID: ${item.id}, DB Pos: ${item.position})">
                            <span class="badge bg-secondary me-2">${item.position + 1}</span> 
                            ${item.mp3_file}
                        </span>
                        <button class="btn btn-sm btn-outline-danger" onclick="deletePlaylistItem(${item.id})" title="Aus Playlist entfernen">
                            <i class="bi bi-trash"></i>
                        </button>
                    `;
                    playlistContainer.appendChild(itemElement);
                });
            }
            
            // 4. Initialize SortableJS again if items exist
            // (Ensure the previous instance is destroyed before creating a new one)
            if (items && items.length > 0) { 
                 try {
                     console.log("Initializing new Sortable instance.");
                     sortablePlaylist = new Sortable(playlistContainer, {
                        animation: 150,
                        ghostClass: 'bg-light',
                        onEnd: function (evt) {
                            console.log("Sortable onEnd event:", evt);
                            const itemId = evt.item.getAttribute('data-id');
                            const newIndex = evt.newIndex;
                            console.log(`Item ID: ${itemId}, Old Index: ${evt.oldIndex}, New Index: ${newIndex}`);
                            if (itemId && newIndex !== null) {
                                 updatePlaylistItemPosition(itemId, newIndex);
                            }
                        }
                    });
                 } catch (e) {
                      console.error("Error initializing SortableJS:", e);
                      // Display an error? Prevent further drag/drop?
                 }
            }
        }
        
        // Position eines Playlist-Items aktualisieren
        function updatePlaylistItemPosition(itemId, newPosition) {
            console.log(`Updating item ${itemId} to position ${newPosition}`);
            // Optionally: Add a visual indicator that saving is in progress

            fetch(`/api/playlist-items/${itemId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ position: newPosition })
            })
            .then(response => {
                 // Check if response is ok (status in the range 200-299)
                 if (!response.ok) {
                     // If not ok, try to parse error json, otherwise throw generic error
                     return response.json().catch(() => {
                         throw new Error(`HTTP error ${response.status}`);
                     }).then(err => { throw new Error(err.error || `HTTP error ${response.status}`) });
                 }
                 return response.json(); // Parse success json
             })
            .then(data => {
                console.log("Update position response:", data);
                if (data.status === 'success') {
                    console.log("Position update reported as success by backend.");
                    // --- Modification: Do NOT reload the whole list on success --- 
                    // We trust the SortableJS visual update for now.
                    // Reloading can cause the snap-back effect.
                    // Only reload if the backend reported an error (handled in catch).
                    
                    // Optional: remove visual indicator for saving
                } else {
                    // Handle cases where backend responds with 2xx status but custom error field
                    console.error("Failed to update position (backend reported error):", data.error);
                    alert('Fehler beim Aktualisieren der Position: ' + data.error);
                    // Reload playlist to revert visual change if backend failed
                     if (currentTagId) {
                         console.log("Reloading playlist due to backend error.");
                         loadPlaylistForTag(currentTagId);
                    }
                }
            })
            .catch(error => {
                 console.error("Network or parsing error updating position:", error);
                 alert('Fehler beim Senden der Positionsänderung: ' + error.message);
                 // Reload playlist to revert visual change on network/other errors
                 if (currentTagId) {
                      console.log("Reloading playlist due to network/parsing error.");
                     loadPlaylistForTag(currentTagId);
                 }
             });
        }
        
        // Tag bearbeiten
        function editTag(tagId, tagName) {
             console.log(`Editing tag: ${tagId}, Name: ${tagName}`);
             document.getElementById('addTagForm').reset();
             document.getElementById('tagId').value = tagId;
             document.getElementById('tagId').readOnly = true;
             document.getElementById('tagName').value = tagName;
             document.querySelector('#addTagModal .modal-title').textContent = 'Tag bearbeiten';
             addTagModal.show();
        }
        
        // Event listener for opening the Add Tag modal via button
        document.querySelector('[data-bs-target="#addTagModal"]').addEventListener('click', () => {
             console.log("Opening Add New Tag modal");
             document.getElementById('addTagForm').reset();
             document.getElementById('tagId').readOnly = false;
             document.querySelector('#addTagModal .modal-title').textContent = 'Neuen Tag hinzufügen';
         });
        
        // Tag hinzufügen/bearbeiten
        document.getElementById('saveTag').addEventListener('click', function() {
            const tagId = document.getElementById('tagId').value.trim();
            const tagName = document.getElementById('tagName').value.trim();
            if (!tagId) {
                alert('Tag ID ist erforderlich.');
                return;
            }
            console.log(`Saving tag - ID: ${tagId}, Name: ${tagName}`);
            
            fetch('/api/tags', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ tag_id: tagId, name: tagName })
            })
            .then(response => {
                 if (!response.ok) {
                      return response.json().then(err => { throw new Error(err.error || `HTTP error ${response.status}`) });
                 }
                 return response.json();
            })
            .then(data => {
                console.log("Save tag response:", data);
                addTagModal.hide();
                loadTags();
                if (tagId === currentTagId) {
                     loadPlaylistForTag(tagId);
                }
            })
            .catch(error => {
                 console.error("Error saving tag:", error);
                 alert('Fehler beim Speichern des Tags: ' + error.message);
             });
        });
        
        // Tag löschen
        function deleteTag(tagId) {
            if (confirm(`Soll der Tag ${tagId} wirklich gelöscht werden? Die zugehörige Playlist wird ebenfalls entfernt!`)) {
                 console.log(`Deleting tag: ${tagId}`);
                fetch(`/api/tags/${tagId}`, {
                    method: 'DELETE'
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Delete tag response:", data);
                    if (data.status === 'success') {
                        loadTags();
                        if (tagId === currentTagId) {
                            currentTagId = null;
                            currentPlaylistId = null;
                            document.getElementById('current-tag').textContent = 'Kein Tag erkannt';
                            document.getElementById('add-to-playlist').disabled = true;
                            displayPlaylistItems([]);
                        }
                    } else {
                        alert('Fehler beim Löschen des Tags: ' + data.error);
                    }
                })
                 .catch(error => {
                     console.error("Error deleting tag:", error);
                     alert('Netzwerkfehler beim Löschen des Tags.');
                 });
            }
        }
        
        // Playlist-Item hinzufügen Button Listener
        document.getElementById('add-to-playlist').addEventListener('click', function() {
            if (!currentPlaylistId) {
                alert('Bitte zuerst einen Tag mit einer Playlist auswählen.');
                return;
            }
            // Nur noch das Modal anzeigen. Das Laden des Inhalts 
            // geschieht jetzt über den 'show.bs.modal' Event Listener.
            console.log("Opening Add Files modal via button click.");
            addToPlaylistModal.show(); 
        });

        // Playlist-Item löschen
        function deletePlaylistItem(itemId) {
             if (!itemId) return;
             console.log(`Deleting playlist item: ${itemId}`);
             if (confirm('Soll dieser Titel wirklich aus der Playlist entfernt werden?')) {
                 fetch(`/api/playlist-items/${itemId}`, {
                    method: 'DELETE'
                })
                .then(response => {
                     if (!response.ok) {
                         return response.json().then(err => { throw new Error(err.error || `HTTP error ${response.status}`) });
                     }
                     return response.json();
                 })
                .then(data => {
                    console.log("Delete item response:", data);
                    if (data.status === 'success') {
                        if (currentTagId) {
                            loadPlaylistForTag(currentTagId);
                        }
                    } else {
                        alert('Fehler beim Löschen des Items: ' + data.error);
                    }
                })
                 .catch(error => {
                     console.error("Error deleting playlist item:", error);
                     alert('Fehler beim Löschen des Items: ' + error.message);
                 });
            }
        }

        // --- File Upload Logic ---

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false); // Prevent browser opening file
        });

        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);

        // Handle file selection via button
        fileInput.addEventListener('change', function(e) {
            handleFiles(this.files);
        });

        function preventDefaults (e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight(e) {
            dropZone.classList.add('bg-light', 'border-primary');
        }

        function unhighlight(e) {
            dropZone.classList.remove('bg-light', 'border-primary');
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        function handleFiles(files) {
            // Log the type of each file for debugging
            console.log("Files selected:");
            [...files].forEach(file => {
                console.log(`  - Name: ${file.name}, Type: ${file.type}`);
            });

            const allowedMimeTypes = ['audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/x-wav', 'application/ogg']; 
            const allowedExtensions = ['.mp3', '.wav', '.ogg'];

            const validFiles = [...files].filter(file => {
                const fileExtension = file.name.slice(file.name.lastIndexOf('.')).toLowerCase();
                // Accept if MIME type is known OR if MIME type is empty AND extension is allowed
                return allowedMimeTypes.includes(file.type) || (file.type === '' && allowedExtensions.includes(fileExtension));
            });
            const invalidFiles = [...files].filter(file => {
                 const fileExtension = file.name.slice(file.name.lastIndexOf('.')).toLowerCase();
                 // Invalid if MIME type is not allowed AND (MIME type is not empty OR extension is not allowed)
                 return !allowedMimeTypes.includes(file.type) && (file.type !== '' || !allowedExtensions.includes(fileExtension));
            });

            if (invalidFiles.length > 0) {
                const invalidNames = invalidFiles.map(f => f.name).join(', ');
                alert(`Folgende Dateien haben keinen erlaubten Typ (MP3, WAV, OGG) und werden ignoriert: ${invalidNames}`);
            }
            
            if (validFiles.length === 0) {
                console.log("No valid MP3 files selected.");
                return;
            }

            uploadProgressDiv.style.display = 'block';
            uploadList.innerHTML = ''; // Clear previous uploads

            validFiles.forEach(file => {
                uploadFile(file);
            });
        }

        function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            const listItem = document.createElement('li');
            listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
            listItem.textContent = `${file.name} (Wird hochgeladen...)`;
            const statusSpan = document.createElement('span');
            statusSpan.className = 'badge bg-secondary rounded-pill';
            statusSpan.textContent = '0%';
            listItem.appendChild(statusSpan);
            uploadList.appendChild(listItem);

            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/api/upload-mp3', true);

            xhr.upload.addEventListener('progress', function(e) {
                if (e.lengthComputable) {
                    const percentComplete = Math.round((e.loaded / e.total) * 100);
                    statusSpan.style.width = percentComplete + '%';
                    statusSpan.setAttribute('aria-valuenow', percentComplete);
                    statusSpan.textContent = percentComplete + '%';
                }
            });

            xhr.onload = function() {
                listItem.classList.remove('uploading');
                statusSpan.classList.add('bg-success');
                statusSpan.textContent = 'Fertig';
                if (xhr.status >= 200 && xhr.status < 300) {
                    console.log("Upload successful, server response:", xhr.responseText);
                    try {
                        const response = JSON.parse(xhr.responseText);
                        if (response.status === 'success') {
                             const originalName = response.original_filename || 'Unbekannt';
                             const savedName = response.saved_filename || 'Unbekannt';
                             const savedPath = response.relative_path || savedName; // Use relative_path if available
                             listItem.textContent = `${originalName} (gespeichert in: ${savedPath})`; // Show path
                             listItem.classList.add('list-group-item-success');
                        } else {
                             listItem.textContent += ` - Fehler: ${response.error || 'Unbekannter Serverfehler'}`;
                             listItem.classList.add('list-group-item-danger');
                        }
                    } catch (e) {
                        console.error("Error parsing upload response:", e);
                        listItem.textContent += ` - Fehler beim Verarbeiten der Serverantwort`;
                        listItem.classList.add('list-group-item-danger');
                    }
                } else {
                    console.error("Upload failed, status:", xhr.status, "Response:", xhr.responseText);
                     let errorMsg = `HTTP-Fehler ${xhr.status}`;
                    try {
                        const response = JSON.parse(xhr.responseText);
                        errorMsg = response.error || errorMsg;
                    } catch (e) { /* Ignore parsing error */ }
                    listItem.textContent += ` - Fehler: ${errorMsg}`;
                    listItem.classList.add('list-group-item-danger');
                    statusSpan.classList.remove('bg-success');
                    statusSpan.classList.add('bg-danger');
                    statusSpan.textContent = 'Fehlgeschlagen';
                }
            };

            xhr.onerror = function() {
                console.error("Network error during upload.");
                listItem.classList.remove('uploading');
                listItem.textContent += ' - Netzwerkfehler';
                listItem.classList.add('list-group-item-danger');
                statusSpan.classList.remove('bg-success');
                statusSpan.classList.add('bg-danger');
                statusSpan.textContent = 'Fehler';
            };

            xhr.send(formData);
        }

        // Function to refresh the MP3 list in the AddToPlaylist modal
        function refreshMp3ListInModal() {
            const selectElement = document.getElementById('mp3Files');
            if (!selectElement) return; // Exit if modal element not found
            console.log("Refreshing MP3 list in modal...");

            fetch('/api/mp3-files')
                .then(response => response.json())
                .then(files => {
                    selectElement.innerHTML = ''; // Clear existing options
                    files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file;
                        selectElement.appendChild(option);
                    });
                    console.log("MP3 list in modal refreshed.");
                })
                .catch(error => {
                    console.error("Error refreshing MP3 files for modal:", error);
                    // Optionally display an error inside the modal?
                });
        }
        
        // --- Functions for 'Add to Playlist' Modal ---

        function loadModalDirectoryContent(path) {
            console.log(`Modal: Loading content for path: ${path}`);
            currentModalPath = path;
            modalLoadingIndicator.style.display = 'block';
            modalFileList.innerHTML = ''; // Clear list while loading
            renderModalBreadcrumbs(path);

            fetch(`/api/media/list-modal-content?path=${encodeURIComponent(path)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(items => {
                    console.log("Modal: Received items:", items);
                    renderModalFileList(items);
                })
                .catch(error => {
                    console.error("Modal: Error loading directory content:", error);
                    modalFileList.innerHTML = '<li class="list-group-item text-danger">Fehler beim Laden des Verzeichnisses.</li>';
                })
                .finally(() => {
                    modalLoadingIndicator.style.display = 'none';
                });
        }

        function renderModalBreadcrumbs(path) {
            modalBreadcrumb.innerHTML = ''; 
            let currentPath = '';
            const pathParts = path.split('/').filter(part => part !== '');

            // Add root breadcrumb
            const rootItem = document.createElement('li');
            rootItem.className = 'breadcrumb-item';
            rootItem.innerHTML = `<a href="#" onclick="loadModalDirectoryContent('/'); return false;">/ (root)</a>`;
            modalBreadcrumb.appendChild(rootItem);

            // Add intermediate parts
            pathParts.forEach((part, index) => {
                currentPath += '/' + part;
                const item = document.createElement('li');
                item.className = 'breadcrumb-item';
                // Make the last part active, others clickable links
                if (index === pathParts.length - 1) {
                    item.classList.add('active');
                    item.setAttribute('aria-current', 'page');
                    item.textContent = part;
                } else {
                     // Ensure correct path for intermediate links
                    const linkPath = ('/ ' + pathParts.slice(0, index + 1).join('/')).replace('/ ','/');
                    item.innerHTML = `<a href="#" onclick="loadModalDirectoryContent('${linkPath}'); return false;">${part}</a>`;
                }
                modalBreadcrumb.appendChild(item);
            });
        }

         function renderModalFileList(items) {
            modalFileList.innerHTML = ''; // Clear previous items

            if (items.length === 0) {
                modalFileList.innerHTML = '<li class="list-group-item text-muted">Ordner ist leer oder enthält keine Audiodateien.</li>';
                return;
            }

            items.forEach(item => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.style.cursor = 'pointer';

                let content = '';
                if (item.type === 'folder') {
                    li.onclick = () => loadModalDirectoryContent(item.path);
                     content = `
                        <div class="d-flex align-items-center text-truncate">
                            <i class="bi bi-folder-fill me-2 text-primary"></i>
                            <span class="text-truncate">${item.name}</span>
                        </div>
                        <i class="bi bi-chevron-right"></i>
                    `;
                } else { // Audio file
                    const isSelected = selectedModalItems.has(item.path);
                    li.onclick = (event) => {
                        // Prevent row click from toggling if checkbox itself is clicked
                        if (event.target.type !== 'checkbox') {
                            toggleModalItemSelection(item.path, li.querySelector('input[type="checkbox"]'));
                         }
                    };
                    content = `
                        <div class="form-check text-truncate">
                             <input class="form-check-input me-2" type="checkbox" value="${item.path}" id="modal-chk-${item.path.replace(/[^a-zA-Z0-9]/g, '_')}" ${isSelected ? 'checked' : ''} onclick="toggleModalItemSelection('${item.path}', this)">
                             <label class="form-check-label text-truncate" for="modal-chk-${item.path.replace(/[^a-zA-Z0-9]/g, '_')}" style="width: 100%;">
                                 <i class="bi bi-file-earmark-music-fill me-1 text-info"></i>
                                 <span class="text-truncate">${item.name}</span>
                             </label>
                         </div>
                        <span></span> <!-- Placeholder for alignment -->
                    `;
                }
                 li.innerHTML = content;
                modalFileList.appendChild(li);
            });
        }
        
        function toggleModalItemSelection(itemPath, checkbox) {
            if (checkbox.checked) {
                selectedModalItems.add(itemPath);
            } else {
                selectedModalItems.delete(itemPath);
            }
            updateModalSelectionUI();
        }
        
         function updateModalSelectionUI() {
             const count = selectedModalItems.size;
             modalSelectionInfo.textContent = `${count} Datei(en) ausgewählt.`;
             modalSaveButton.disabled = count === 0;
         }

        // --- Function to save selected files to the current playlist ---
        function saveModalSelectionToPlaylist() {
            if (!currentPlaylistId) {
                alert("Keine Playlist ausgewählt oder geladen.");
                return;
            }
            const filesToAdd = Array.from(selectedModalItems);
            if (filesToAdd.length === 0) {
                alert("Keine Dateien zum Hinzufügen ausgewählt.");
                return;
            }

            console.log(`Modal: Adding ${filesToAdd.length} files to Playlist ID: ${currentPlaylistId}`);
            const saveButton = modalSaveButton;
            const spinner = saveButton.querySelector('.spinner-border');
            saveButton.disabled = true;
            spinner.style.display = 'inline-block';

            // Use the existing BATCH API endpoint to add items
            fetch(`/api/playlists/${currentPlaylistId}/items/batch`, { // Use the /batch endpoint
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                 // Use the key expected by the batch endpoint
                body: JSON.stringify({ mp3_files: filesToAdd }) 
            })
            .then(response => {
                 if (!response.ok) {
                    // Attempt to read error message from response
                    return response.json().then(errData => {
                         throw new Error(errData.error || `Serverfehler: ${response.status}`);
                    }).catch(() => {
                         // Fallback if error response is not JSON
                         throw new Error(`Serverfehler: ${response.status}`);
                    });
                 } 
                return response.json();
            })
            .then(data => {
                console.log("Modal: Add items response:", data);
                alert(`${filesToAdd.length} Datei(en) erfolgreich zur Playlist hinzugefügt.`);
                addToPlaylistModal.hide(); // Close the modal
                // Reload the main playlist view to show the new items
                loadPlaylistForTag(currentTagId);
                // Optional: Clear selection in modal (already done on modal open)
                // selectedModalItems.clear();
                // updateModalSelectionUI();
            })
            .catch(error => {
                console.error("Modal: Error adding files to playlist:", error);
                alert(`Fehler beim Hinzufügen: ${error.message}`);
            })
            .finally(() => {
                 saveButton.disabled = false; // Re-enable button
                 spinner.style.display = 'none';
            });
        }

        // Initialisierung beim Laden der Seite
        loadTags();
    </script>
</body>
</html> 